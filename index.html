<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Annotate - Codmegle</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        /* ============================================
           THEME SYSTEM - CSS CUSTOM PROPERTIES
           ============================================ */

        :root {
            /* Light Theme Colors */
            --bg-primary: #ffffff;
            --bg-secondary: #f8fafc;
            --bg-tertiary: #f1f5f9;
            --bg-gradient-start: #f9fafb;
            --bg-gradient-end: #ffffff;
            
            --text-primary: #111827;
            --text-secondary: #6b7280;
            --text-tertiary: #9ca3af;
            --text-inverse: #ffffff;
            
            --border-primary: #e5e7eb;
            --border-secondary: #d1d5db;
            --border-tertiary: #cbd5e1;
            
            --accent-primary: #3b82f6;
            --accent-primary-hover: #2563eb;
            --accent-primary-light: #dbeafe;
            --accent-secondary: #10b981;
            
            --message-you-bg: linear-gradient(135deg, #3B82F6 0%, #2563EB 100%);
            --message-stranger-bg: #ffffff;
            --message-stranger-border: #e5e7eb;
            
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            
            --modal-overlay: rgba(0, 0, 0, 0.6);
            --modal-bg: #ffffff;
            
            --input-bg: #ffffff;
            --input-border: #d1d5db;
            --input-border-focus: #3b82f6;
            --input-disabled-bg: #f3f4f6;
            --input-disabled-text: #9ca3af;
            
            --button-primary-bg: linear-gradient(135deg, #3B82F6 0%, #2563EB 100%);
            --button-secondary-bg: #ffffff;
            --button-secondary-border: #d1d5db;
            --button-secondary-hover: #f3f4f6;
            
            --status-online: #10b981;
            --status-warning: #f59e0b;
            --status-error: #ef4444;
            
            --video-bg: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #0f172a 100%);
            --video-overlay: rgba(0, 0, 0, 0.7);
        }

        [data-theme="dark"] {
            /* Dark Theme Colors */
            --bg-primary: #111827;
            --bg-secondary: #1f2937;
            --bg-tertiary: #374151;
            --bg-gradient-start: #1f2937;
            --bg-gradient-end: #111827;
            
            --text-primary: #f9fafb;
            --text-secondary: #d1d5db;
            --text-tertiary: #9ca3af;
            --text-inverse: #111827;
            
            --border-primary: #374151;
            --border-secondary: #4b5563;
            --border-tertiary: #6b7280;
            
            --accent-primary: #60a5fa;
            --accent-primary-hover: #3b82f6;
            --accent-primary-light: #1e3a8a;
            --accent-secondary: #34d399;
            
            --message-you-bg: linear-gradient(135deg, #3B82F6 0%, #2563EB 100%);
            --message-stranger-bg: #374151;
            --message-stranger-border: #4b5563;
            
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.4), 0 2px 4px -1px rgba(0, 0, 0, 0.3);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.4), 0 4px 6px -2px rgba(0, 0, 0, 0.3);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.5), 0 10px 10px -5px rgba(0, 0, 0, 0.4);
            
            --modal-overlay: rgba(0, 0, 0, 0.8);
            --modal-bg: #1f2937;
            
            --input-bg: #374151;
            --input-border: #4b5563;
            --input-border-focus: #60a5fa;
            --input-disabled-bg: #1f2937;
            --input-disabled-text: #6b7280;
            
            --button-primary-bg: linear-gradient(135deg, #3B82F6 0%, #2563EB 100%);
            --button-secondary-bg: #374151;
            --button-secondary-border: #4b5563;
            --button-secondary-hover: #4b5563;
            
            --status-online: #10b981;
            --status-warning: #f59e0b;
            --status-error: #ef4444;
            
            --video-bg: linear-gradient(135deg, #000000 0%, #1a1a1a 50%, #000000 100%);
            --video-overlay: rgba(0, 0, 0, 0.85);
        }

        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            font-weight: 400;
            letter-spacing: -0.01em;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .body-theme {
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            color: var(--text-primary);
        }

        .chat-screen-theme {
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
        }

        /* ============================================
           HEADER THEME STYLING
           ============================================ */

        .header-main {
            background-color: var(--bg-primary);
            border-color: var(--border-primary);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }

        .header-logo-text {
            color: var(--text-primary);
        }

        .header-online-text {
            color: var(--text-secondary);
        }

        .header-online-bg {
            background-color: var(--bg-tertiary);
        }

        .theme-toggle-btn {
            color: var(--text-secondary);
            background-color: transparent;
            border: none;
            cursor: pointer;
        }

        .theme-toggle-btn:hover {
            background-color: var(--bg-tertiary);
        }

        .theme-icon-light,
        .theme-icon-dark {
            color: var(--text-secondary);
            transition: color 0.3s ease;
        }

        [data-theme="dark"] .theme-icon-light {
            display: none;
        }

        [data-theme="dark"] .theme-icon-dark {
            display: block !important;
        }

        [data-theme="light"] .theme-icon-dark,
        :root:not([data-theme]) .theme-icon-dark {
            display: none;
        }

        [data-theme="light"] .theme-icon-light,
        :root:not([data-theme]) .theme-icon-light {
            display: block;
        }

        /* ============================================
           HEADER RESPONSIVENESS
           ============================================ */

        .header-responsive {
            min-height: 48px;
            height: auto;
        }

        @media (max-width: 639px) {
            body {
                -webkit-tap-highlight-color: transparent;
            }
            input, textarea, select {
                font-size: 16px !important;
            }
            
            .header-responsive {
                min-height: 44px;
                padding: 0.5rem 0.75rem;
            }
            
            .header-online-count {
                font-size: 0.625rem;
                padding: 0.25rem 0.5rem;
            }
        }

        @media (min-width: 640px) and (max-width: 767px) {
            .header-responsive {
                min-height: 52px;
            }
        }

        @media (min-width: 768px) {
            .header-responsive {
                min-height: 56px;
            }
        }

        /* ============================================
           MOBILE OPTIMIZATIONS
           ============================================ */

        @media (max-width: 640px) {
            .mobile-input {
                font-size: 16px !important;
            }
            
            .touch-target {
                min-width: 44px;
                min-height: 44px;
            }
        }

        /* ============================================
           SCROLLBAR STYLING
           ============================================ */

        ::-webkit-scrollbar { width: 10px; }
        ::-webkit-scrollbar-track { background: var(--bg-tertiary); border-radius: 5px; }
        ::-webkit-scrollbar-thumb { background: var(--border-tertiary); border-radius: 5px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--border-secondary); }

        /* ============================================
           ANNOTATE PAGE SPECIFIC STYLES
           ============================================ */
        
        /* Custom scrollbar for tool area (overrides general scrollbar) */
        .annotate-toolbar ::-webkit-scrollbar {
            width: 6px;
        }
        .annotate-toolbar ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }
        .annotate-toolbar ::-webkit-scrollbar-thumb {
            background: var(--border-primary);
            border-radius: 3px;
        }
        
        /* Cursor logic */
        .cursor-crosshair {
            cursor: crosshair;
        }
        .canvas-container {
            touch-action: none; /* Prevent scrolling while drawing */
        }
        
        /* Range Slider Styling */
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: var(--accent-primary);
            margin-top: -6px; 
            cursor: pointer;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: var(--border-primary);
            border-radius: 2px;
        }

        /* Theme-aware colors */
        .annotate-header {
            background-color: var(--bg-secondary);
            border-color: var(--border-primary);
        }

        .annotate-toolbar {
            background-color: var(--bg-secondary);
            border-color: var(--border-primary);
        }

        .annotate-tool-btn-active {
            background: var(--button-primary-bg);
            color: var(--text-inverse);
        }

        .annotate-tool-btn {
            color: var(--text-secondary);
        }

        .annotate-tool-btn:hover {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .annotate-mode-btn-active {
            background: var(--button-primary-bg);
            color: var(--text-inverse);
        }

        .annotate-mode-btn {
            color: var(--text-secondary);
        }

        .annotate-mode-btn:hover {
            background-color: var(--bg-tertiary);
        }

        .annotate-canvas-wrapper {
            background-color: var(--bg-primary);
        }

        .annotate-bg-whiteboard {
            background-color: var(--bg-primary);
        }

        .annotate-bg-screen {
            background-color: var(--bg-primary);
        }

        .annotate-bg-image {
            background-color: var(--bg-primary);
        }

        .annotate-placeholder {
            color: var(--text-secondary);
        }

        .annotate-controls {
            background-color: var(--bg-secondary);
            border-color: var(--border-primary);
        }

        .annotate-footer {
            background-color: var(--bg-secondary);
            border-color: var(--border-primary);
            color: var(--text-tertiary);
        }

        /* Collaboration Modal */
        #collaboration-modal-overlay {
            animation: fadeIn 0.2s ease-out;
        }

        #collaboration-modal {
            animation: slideUp 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        #btn-host-session:hover {
            transform: translateY(-2px);
        }

        /* Ensure all elements use theme colors */
        body {
            color: var(--text-primary);
        }

        /* Connection status dot colors */
        #connection-dot[style*="green"] {
            background-color: #10b981 !important;
        }
        #connection-dot[style*="yellow"] {
            background-color: #f59e0b !important;
        }
        #connection-dot[style*="blue"] {
            background-color: #3b82f6 !important;
        }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden font-sans select-none body-theme">

    <!-- Header -->
    <header class="header-main border-b p-2.5 sm:p-3 md:p-4 flex justify-between items-center shadow-md header-responsive shrink-0 z-10 backdrop-blur-sm annotate-header">
        <div class="flex items-center select-none cursor-pointer group" onclick="window.location.href='index.html'">
            <span class="text-xl sm:text-2xl md:text-3xl font-extrabold tracking-tight header-logo-text group-hover:text-blue-600 transition-colors">CFD</span>
            <span class="text-xl sm:text-2xl md:text-3xl font-extrabold tracking-tight text-white bg-gradient-to-r from-orange-500 to-orange-600 px-1 sm:px-1.5 md:px-2 py-0.5 transform -rotate-2 shadow-lg inline-block ml-0.5 sm:ml-1 rounded-md group-hover:shadow-xl transition-shadow">Penny</span>
        </div>
        <div class="flex items-center gap-2 sm:gap-2.5 md:gap-3">
            <!-- Connection Status -->
            <div id="connection-status" class="hidden flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm" style="background-color: var(--bg-tertiary);">
                <div id="connection-dot" class="h-2 w-2 rounded-full" style="background-color: var(--text-secondary);"></div>
                <span id="connection-text" style="color: var(--text-secondary);">Disconnected</span>
                <span id="share-code-display" class="hidden font-mono font-bold ml-2" style="color: var(--accent-primary);"></span>
            </div>
            <button id="btn-collaborate" class="px-3 py-1.5 rounded-lg text-sm font-medium transition-all" style="background-color: var(--button-secondary-bg); color: var(--text-primary); border: 1px solid var(--button-secondary-border);" title="Start/Stop Collaboration">
                <i data-lucide="users" class="w-4 h-4 inline mr-1"></i>
                <span class="hidden sm:inline">Collaborate</span>
            </button>
            <button id="theme-toggle" onclick="app.toggleTheme()" class="theme-toggle-btn flex items-center justify-center w-9 h-9 sm:w-10 sm:h-10 rounded-lg transition-all active:scale-95" title="Toggle theme">
                <i data-lucide="sun" class="w-5 h-5 theme-icon-light"></i>
                <i data-lucide="moon" class="w-5 h-5 theme-icon-dark hidden"></i>
            </button>
        </div>
    </header>

    <!-- Top Toolbar -->
    <header class="h-14 annotate-header border-b flex items-center justify-between px-4 z-20 shrink-0">
        <div class="flex items-center space-x-2">
            <div class="bg-indigo-500 p-1.5 rounded-lg">
                <i data-lucide="pencil" class="text-white w-5 h-5"></i>
            </div>
            
            <div class="h-6 w-px mx-2" style="background-color: var(--border-primary);"></div>
            
            <!-- Mode Switchers -->
            <div class="flex bg-gray-700 rounded-lg p-1 space-x-1" style="background-color: var(--bg-tertiary);">
                <button id="btn-mode-board" class="annotate-mode-btn px-3 py-1.5 rounded-md text-sm font-medium flex items-center space-x-1 transition-colors annotate-mode-btn-active">
                    <i data-lucide="square" class="w-3.5 h-3.5"></i>
                    <span>Board</span>
                </button>
                <button id="btn-mode-screen" class="annotate-mode-btn px-3 py-1.5 rounded-md text-sm font-medium flex items-center space-x-1 transition-colors">
                    <i data-lucide="monitor" class="w-3.5 h-3.5"></i>
                    <span>Screen</span>
                </button>
                <button id="btn-mode-image" class="annotate-mode-btn px-3 py-1.5 rounded-md text-sm font-medium flex items-center space-x-1 transition-colors">
                    <i data-lucide="image" class="w-3.5 h-3.5"></i>
                    <span>Image</span>
                </button>
                <input type="file" id="file-input" class="hidden" accept="image/*">
            </div>
        </div>

        <div class="flex items-center space-x-3">
            <button id="btn-undo" class="p-2 rounded disabled:opacity-30 disabled:cursor-not-allowed" disabled style="color: var(--text-primary); background-color: var(--bg-tertiary);" onmouseover="this.style.backgroundColor='var(--bg-tertiary)'" onmouseout="this.style.backgroundColor='var(--bg-tertiary)'">
                <i data-lucide="undo" class="w-4 h-4"></i>
            </button>
            <button id="btn-redo" class="p-2 rounded disabled:opacity-30 disabled:cursor-not-allowed" disabled style="color: var(--text-primary); background-color: var(--bg-tertiary);" onmouseover="this.style.backgroundColor='var(--bg-tertiary)'" onmouseout="this.style.backgroundColor='var(--bg-tertiary)'">
                <i data-lucide="redo" class="w-4 h-4"></i>
            </button>
            <button id="btn-snapshot" class="flex items-center space-x-2 bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-1.5 rounded-md text-sm font-medium transition-colors">
                <i data-lucide="camera" class="w-4 h-4"></i>
                <span class="hidden sm:inline">Snapshot</span>
            </button>
        </div>
    </header>

    <!-- Main Workspace -->
    <div class="flex-1 relative overflow-hidden flex" id="workspace-container" style="background-color: var(--bg-primary);">
        
        <!-- Toolbar Sidebar -->
        <div class="w-16 annotate-toolbar border-r flex flex-col items-center py-4 space-y-4 z-20 shadow-xl shrink-0 h-full overflow-y-auto">
            
            <!-- Tools -->
            <div class="flex flex-col space-y-2 w-full px-2" id="tool-container">
                <!-- Generated by JS -->
            </div>

            <div class="w-8 h-px my-2 shrink-0" style="background-color: var(--border-primary);"></div>

            <!-- Colors -->
            <div class="flex flex-col space-y-2 px-2" id="color-container">
                <!-- Generated by JS -->
                <!-- Custom Color Picker Wrapper -->
                <div class="relative group w-6 h-6 mx-auto">
                    <div class="w-6 h-6 rounded-full border-2 border-gray-500 bg-gradient-to-br from-red-500 to-blue-500 cursor-pointer" style="border-color: var(--border-primary);"></div>
                    <input type="color" id="custom-color-picker" class="absolute inset-0 opacity-0 cursor-pointer w-full h-full">
                </div>
            </div>

            <div class="w-8 h-px my-2 shrink-0" style="background-color: var(--border-primary);"></div>

            <!-- Clear Action -->
            <button id="btn-clear" class="p-3 rounded-xl transition-colors" title="Clear All" style="color: var(--status-error);" onmouseover="this.style.backgroundColor='var(--bg-tertiary)'" onmouseout="this.style.backgroundColor='transparent'">
                <i data-lucide="trash-2" class="w-5 h-5"></i>
            </button>

            <!-- Stroke Width Slider -->
            <div class="mt-auto mb-4 group relative px-2">
                <div class="p-2 rounded-lg cursor-pointer" style="background-color: var(--bg-tertiary);">
                    <div id="stroke-indicator" class="w-4 bg-white rounded-full mx-auto" style="height: 4px; background-color: var(--text-primary);"></div>
                </div>
                <div class="absolute left-full ml-2 bottom-0 p-3 rounded-lg border hidden group-hover:flex flex-col space-y-3 w-32 shadow-xl z-50 annotate-controls">
                    <span class="text-xs font-medium" style="color: var(--text-secondary);">Stroke Width</span>
                    <input type="range" id="stroke-slider" min="2" max="30" value="4" class="w-full accent-indigo-500">
                </div>
            </div>
        </div>

        <!-- Canvas Area -->
        <div class="flex-1 relative overflow-hidden flex items-center justify-center canvas-container annotate-canvas-wrapper" id="canvas-wrapper">
            
            <!-- Background Layer -->
            <div id="background-layer" class="absolute inset-0 flex items-center justify-center pointer-events-none w-full h-full">
                <!-- Whiteboard BG -->
                <div id="bg-whiteboard" class="w-full h-full annotate-bg-whiteboard transition-colors duration-500"></div>
                
                <!-- Screen/Video BG -->
                <div id="bg-screen" class="hidden w-full h-full relative flex items-center justify-center">
                    <video id="screen-video" autoplay playsinline muted class="max-w-full max-h-full object-contain"></video>
                    
                    <div id="screen-placeholder" class="absolute inset-0 flex flex-col items-center justify-center annotate-placeholder" style="background-color: var(--bg-primary);">
                        <i data-lucide="monitor" class="mb-4 opacity-50 w-16 h-16"></i>
                        <p class="text-xl font-medium">Click "Screen" to start sharing</p>
                    </div>

                    <!-- Screen Controls -->
                    <div id="screen-controls" class="absolute bottom-6 left-1/2 -translate-x-1/2 flex space-x-2 pointer-events-auto backdrop-blur-sm p-2 rounded-full border shadow-2xl z-30 hidden annotate-controls">
                        <button id="btn-pause-video" class="p-2 hover:bg-white/10 rounded-full text-white transition-colors">
                            <i id="icon-pause" data-lucide="pause" class="w-5 h-5"></i>
                            <i id="icon-play" data-lucide="play" class="w-5 h-5 hidden"></i>
                        </button>
                        <div class="w-px my-1" style="background-color: var(--border-primary);"></div>
                        <button id="btn-stop-share" class="p-2 hover:bg-red-500/20 text-red-400 rounded-full transition-colors">
                            <i data-lucide="x" class="w-5 h-5"></i>
                        </button>
                    </div>

                    <div id="video-frozen-badge" class="absolute top-4 left-1/2 -translate-x-1/2 bg-yellow-500/90 text-black px-3 py-1 rounded-full text-xs font-bold uppercase tracking-wider shadow-lg hidden">
                        Video Frozen
                    </div>
                </div>

                <!-- Image BG -->
                <div id="bg-image" class="hidden w-full h-full relative flex items-center justify-center">
                    <img id="uploaded-image" src="" class="max-w-full max-h-full object-contain select-none hidden" alt="Annotation Background">
                    <div id="image-placeholder" class="annotate-placeholder flex flex-col items-center">
                        <i data-lucide="image" class="mb-2 opacity-50 w-12 h-12"></i>
                        <span>No image selected</span>
                    </div>
                </div>
            </div>

            <!-- Drawing Canvas -->
            <canvas id="main-canvas" class="absolute inset-0 w-full h-full cursor-crosshair z-10"></canvas>

            <!-- Text Input Overlay (Hidden by default) -->
            <input type="text" id="text-tool-input" class="absolute z-20 bg-transparent border text-indigo-600 outline-none p-1 rounded shadow-lg min-w-[100px] hidden" placeholder="Type..." autocomplete="off" style="border-color: var(--accent-primary); color: var(--accent-primary);">

        </div>
    </div>
    <!-- Collaboration Modal -->
    <div id="collaboration-modal-overlay" class="hidden fixed inset-0 bg-black/60 backdrop-blur-sm z-50 flex items-center justify-center p-4" onclick="closeCollaborationModal(event)">
        <div id="collaboration-modal" class="relative bg-gray-800 rounded-2xl shadow-2xl max-w-md w-full border border-gray-700" onclick="event.stopPropagation()" style="background-color: var(--bg-secondary); border-color: var(--border-primary);">
            <!-- Header -->
            <div class="flex items-center justify-between p-6 border-b" style="border-color: var(--border-primary);">
                <div class="flex items-center gap-3">
                    <div class="w-10 h-10 rounded-lg flex items-center justify-center" style="background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);">
                        <i data-lucide="users" class="w-6 h-6 text-white"></i>
                    </div>
                    <h2 class="text-2xl font-bold" style="color: var(--text-primary);">Collaboration</h2>
                </div>
                <button id="close-collaboration-modal" class="w-8 h-8 flex items-center justify-center rounded-lg transition-colors" style="color: var(--text-primary);" onmouseover="this.style.backgroundColor='var(--bg-tertiary)'" onmouseout="this.style.backgroundColor='transparent'" onclick="closeCollaborationModal()">
                    <i data-lucide="x" class="w-5 h-5"></i>
                </button>
            </div>

            <!-- Content -->
            <div class="p-6 space-y-4">
                <!-- Host Session -->
                <button id="btn-host-session" class="w-full p-5 rounded-xl border-2 transition-all hover:border-indigo-500 hover:shadow-lg text-left group" style="background-color: var(--bg-tertiary); border-color: var(--border-primary);" onclick="handleHostSession()">
                    <div class="font-bold text-lg mb-1" style="color: var(--text-primary);">Host Session</div>
                    <div class="text-sm" style="color: var(--text-secondary);">Create a room and share your screen</div>
                </button>

                <!-- OR Separator -->
                <div class="flex items-center gap-4">
                    <div class="flex-1 h-px" style="background-color: var(--border-primary);"></div>
                    <span class="text-sm font-medium" style="color: var(--text-secondary);">OR</span>
                    <div class="flex-1 h-px" style="background-color: var(--border-primary);"></div>
                </div>

                <!-- Join Session -->
                <div class="flex gap-3">
                    <input 
                        type="text" 
                        id="join-code-input" 
                        placeholder="ENTER CODE" 
                        maxlength="5"
                        class="flex-1 px-4 py-3 rounded-xl border-2 focus:outline-none focus:border-indigo-500 transition-all font-mono text-center text-lg tracking-widest uppercase"
                        style="background-color: var(--bg-tertiary); border-color: var(--border-primary); color: var(--text-primary);"
                        onkeydown="if(event.key === 'Enter') handleJoinSession()"
                    >
                    <button 
                        id="btn-join-session" 
                        class="px-6 py-3 rounded-xl font-semibold text-white transition-all hover:shadow-lg"
                        style="background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);"
                        onclick="handleJoinSession()"
                    >
                        Join
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Constants & Config ---
        const COLORS = [
            '#FF3B30', '#FF9500', '#FFCC00', '#4CD964', '#5AC8FA', '#007AFF', '#5856D6', '#FFFFFF', '#000000'
        ];
        
        const TOOLS = [
            { id: 'pencil', icon: 'pencil', label: 'Pen' },
            { id: 'arrow', icon: 'arrow-right', label: 'Arrow' },
            { id: 'rect', icon: 'square', label: 'Box' },
            { id: 'text', icon: 'type', label: 'Text' },
            { id: 'eraser', icon: 'eraser', label: 'Eraser' },
        ];

        // --- State ---
        let state = {
            mode: 'whiteboard', // 'whiteboard', 'screen', 'image'
            tool: 'pencil',
            color: '#FF3B30',
            strokeWidth: 4,
            isDrawing: false,
            elements: [], // History array
            historyStep: -1, // Current position in history
            stream: null,
            isVideoPaused: false,
            backgroundImageSrc: null,
            textInput: null, // {x, y, text}
            // Peer collaboration state
            peer: null,
            dataConnection: null,
            call: null,
            isCollaborating: false,
            isHosting: false,
            shareCode: null,
            peerElements: [] // Elements from peer
        };

        // --- DOM Elements ---
        const canvas = document.getElementById('main-canvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('workspace-container');
        const toolContainer = document.getElementById('tool-container');
        const colorContainer = document.getElementById('color-container');
        const textInputElem = document.getElementById('text-tool-input');
        const strokeSlider = document.getElementById('stroke-slider');
        const strokeIndicator = document.getElementById('stroke-indicator');
        const videoElem = document.getElementById('screen-video');
        const videoPlaceholder = document.getElementById('screen-placeholder');
        const videoControls = document.getElementById('screen-controls');
        const imgElem = document.getElementById('uploaded-image');
        const imgPlaceholder = document.getElementById('image-placeholder');

        // --- Theme Management ---
        const app = {
            initTheme: function() {
                const savedTheme = localStorage.getItem('codmegle_theme');
                const systemPrefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                
                let theme = savedTheme || (systemPrefersDark ? 'dark' : 'light');
                this.setTheme(theme);
                
                if (window.matchMedia) {
                    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
                        if (!localStorage.getItem('codmegle_theme')) {
                            this.setTheme(e.matches ? 'dark' : 'light');
                        }
                    });
                }
            },
            
            setTheme: function(theme) {
                document.documentElement.setAttribute('data-theme', theme);
                localStorage.setItem('codmegle_theme', theme);
                
                const themeToggle = document.getElementById('theme-toggle');
                if (themeToggle) {
                    const lightIcon = themeToggle.querySelector('.theme-icon-light');
                    const darkIcon = themeToggle.querySelector('.theme-icon-dark');
                    if (lightIcon && darkIcon) {
                        if (theme === 'dark') {
                            lightIcon.classList.add('hidden');
                            darkIcon.classList.remove('hidden');
                        } else {
                            darkIcon.classList.add('hidden');
                            lightIcon.classList.remove('hidden');
                        }
                    }
                }
                
                if (window.lucide) {
                    lucide.createIcons();
                }
                
                // Update whiteboard background based on theme
                updateWhiteboardBackground();
            },
            
            toggleTheme: function() {
                const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
                const newTheme = currentTheme === 'light' ? 'dark' : 'light';
                this.setTheme(newTheme);
            }
        };

        function updateWhiteboardBackground() {
            const theme = document.documentElement.getAttribute('data-theme') || 'light';
            const whiteboardBg = document.getElementById('bg-whiteboard');
            if (whiteboardBg) {
                whiteboardBg.style.backgroundColor = theme === 'dark' ? '#1f2937' : '#ffffff';
            }
        }

        // --- Peer Collaboration ---
        
        function updateConnectionStatus(isConnected, shareCode = null, statusText = null) {
            const statusEl = document.getElementById('connection-status');
            const dotEl = document.getElementById('connection-dot');
            const textEl = document.getElementById('connection-text');
            const codeEl = document.getElementById('share-code-display');
            const btnEl = document.getElementById('btn-collaborate');
            
            if (!statusEl || !dotEl || !textEl || !btnEl) return;
            
            if (isConnected) {
                statusEl.classList.remove('hidden');
                dotEl.style.backgroundColor = '#10b981'; // green
                textEl.textContent = statusText || 'Connected';
                if (shareCode) {
                    codeEl.textContent = shareCode;
                    codeEl.classList.remove('hidden');
                }
                btnEl.innerHTML = '<i data-lucide="users" class="w-4 h-4 inline mr-1"></i><span class="hidden sm:inline">Stop</span>';
                btnEl.style.backgroundColor = 'var(--status-error)';
                btnEl.style.color = 'white';
            } else if (shareCode) {
                statusEl.classList.remove('hidden');
                dotEl.style.backgroundColor = '#f59e0b'; // yellow
                textEl.textContent = statusText || 'Waiting for peer...';
                codeEl.textContent = shareCode;
                codeEl.classList.remove('hidden');
                btnEl.innerHTML = '<i data-lucide="users" class="w-4 h-4 inline mr-1"></i><span class="hidden sm:inline">Stop</span>';
            } else if (statusText) {
                // Show status even without share code (e.g., "Connecting...")
                statusEl.classList.remove('hidden');
                dotEl.style.backgroundColor = '#3b82f6'; // blue for connecting
                textEl.textContent = statusText;
                codeEl.classList.add('hidden');
                btnEl.innerHTML = '<i data-lucide="users" class="w-4 h-4 inline mr-1"></i><span class="hidden sm:inline">Stop</span>';
            } else {
                statusEl.classList.add('hidden');
                codeEl.classList.add('hidden');
                btnEl.innerHTML = '<i data-lucide="users" class="w-4 h-4 inline mr-1"></i><span class="hidden sm:inline">Collaborate</span>';
                btnEl.style.backgroundColor = 'var(--button-secondary-bg)';
                btnEl.style.color = 'var(--text-primary)';
            }
            if (window.lucide) lucide.createIcons();
        }

        function sendToPeer(message) {
            if (!state.isCollaborating) {
                return false;
            }
            if (!state.dataConnection) {
                return false;
            }
            if (!state.dataConnection.open) {
                return false;
            }
            try {
                const messageStr = JSON.stringify(message);
                state.dataConnection.send(messageStr);
                return true;
            } catch (err) {
                console.error('sendToPeer: Error sending message:', message.type, err);
                return false;
            }
        }

        async function startCollaboration() {
            if (state.isCollaborating) {
                stopCollaboration();
                return;
            }

            try {
                // Generate share code
                const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
                let shareCode = '';
                for (let i = 0; i < 5; i++) {
                    shareCode += chars.charAt(Math.floor(Math.random() * chars.length));
                }

                state.peer = new Peer(shareCode, {
                    debug: 1,
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' }
                        ]
                    }
                });

                state.isHosting = true;
                state.shareCode = shareCode;
                updateConnectionStatus(false, shareCode);

                state.peer.on('open', (id) => {
                    // Don't set isCollaborating here - wait for data connection to open
                    // This ensures we only mark as collaborating when actually connected
                });

                state.peer.on('connection', (dataConnection) => {
                    if (state.dataConnection) {
                        dataConnection.close();
                        return;
                    }
                    state.dataConnection = dataConnection;
                    setupDataConnection(dataConnection);
                });

                state.peer.on('call', (incomingCall) => {
                    if (state.call) {
                        // If we already have a call, close the new one
                        incomingCall.close();
                        return;
                    }
                    
                    // Answer with current screen share if available, otherwise dummy stream
                    let streamToShare = null;
                    if (state.mode === 'screen' && state.stream) {
                        streamToShare = state.stream;
                    } else {
                        // Create dummy stream for non-screen modes
                        const canvas = document.createElement('canvas');
                        canvas.width = 1;
                        canvas.height = 1;
                        streamToShare = canvas.captureStream ? canvas.captureStream(1) : null;
                    }
                    
                    if (streamToShare) {
                        incomingCall.answer(streamToShare);
                        state.call = incomingCall;
                        setupCallHandlers(incomingCall);
                    } else {
                        incomingCall.close();
                    }
                });

                state.peer.on('error', (err) => {
                    console.error('Peer error (host):', err);
                    
                    // Handle specific errors
                    if (err.type === 'peer-unavailable') {
                        // This is expected if someone tries to connect before we're ready
                    } else if (err.type === 'network') {
                        alert('Network error. Please check your internet connection.');
                    }
                });

            } catch (err) {
                console.error('Error starting collaboration:', err);
                alert('Failed to start collaboration: ' + err.message);
            }
        }

        function setupDataConnection(dataConnection) {
            if (!dataConnection) {
                return;
            }

            // If connection is already open (e.g., peer initiated connection), set state immediately
            // Check both 'open' property and readyState for reliability
            const isAlreadyOpen = dataConnection.open || dataConnection.readyState === 'open';
            if (isAlreadyOpen) {
                state.isCollaborating = true;
                updateConnectionStatus(true, state.shareCode);
                
                // Send current canvas state to peer (only if we're the host)
                if (state.isHosting) {
                    sendToPeer({
                        type: 'ANNOTATION_SYNC',
                        elements: state.elements,
                        historyStep: state.historyStep
                    });
                }
            } else {
                // Connection not open yet, wait for open event
                dataConnection.on('open', () => {
                    state.isCollaborating = true;
                    updateConnectionStatus(true, state.shareCode);
                    
                    // Send current canvas state to peer (only if we're the host)
                    if (state.isHosting) {
                        sendToPeer({
                            type: 'ANNOTATION_SYNC',
                            elements: state.elements,
                            historyStep: state.historyStep
                        });
                    }
                });
            }

            // Always set up data handlers (regardless of connection state)
            dataConnection.on('data', (data) => {
                try {
                    const message = JSON.parse(data);
                    handlePeerMessage(message);
                } catch (err) {
                    console.error('Error parsing peer message:', err, 'raw data:', data);
                }
            });

            dataConnection.on('close', () => {
                state.dataConnection = null;
                state.isCollaborating = false;
                updateConnectionStatus(false);
            });

            dataConnection.on('error', (err) => {
                console.error('Data connection error, isHosting:', state.isHosting, err);
            });
        }

        function handlePeerMessage(message) {
            switch (message.type) {
                case 'ANNOTATION_START':
                    // Peer started drawing
                    const newPeerElement = {
                        id: message.id || `peer-${Date.now()}-${Math.random()}`,
                        type: message.tool,
                        color: message.color,
                        width: message.width,
                        points: [{ x: message.x, y: message.y }],
                        start: { x: message.x, y: message.y },
                        end: { x: message.x, y: message.y },
                        isPeer: true,
                        isActive: true // Mark as active drawing
                    };
                    state.peerElements.push(newPeerElement);
                    redrawCanvas();
                    break;
                case 'ANNOTATION_MOVE':
                    // Peer moved while drawing - find the active element by ID or last active element
                    let activePeerEl = null;
                    if (message.id) {
                        // Try to find by ID first
                        activePeerEl = state.peerElements.find(el => el.id === message.id && el.isPeer);
                    }
                    // Fallback to last active element if ID not found
                    if (!activePeerEl) {
                        // Find last element that matches the tool type and is active
                        for (let i = state.peerElements.length - 1; i >= 0; i--) {
                            const el = state.peerElements[i];
                            if (el.isPeer && el.isActive && el.type === message.tool) {
                                activePeerEl = el;
                                break;
                            }
                        }
                    }
                    // Last resort: use the last peer element
                    if (!activePeerEl) {
                        const lastEl = state.peerElements[state.peerElements.length - 1];
                        if (lastEl && lastEl.isPeer) {
                            activePeerEl = lastEl;
                        }
                    }
                    
                    if (activePeerEl) {
                        if (message.tool === 'pencil' || message.tool === 'eraser') {
                            activePeerEl.points.push({ x: message.x, y: message.y });
                        } else {
                            activePeerEl.end = { x: message.x, y: message.y };
                        }
                        redrawCanvas();
                    } else {
                        // Create new element as fallback
                        state.peerElements.push({
                            id: message.id || `peer-${Date.now()}-${Math.random()}`,
                            type: message.tool,
                            color: state.color, // Use default color if not provided
                            width: state.strokeWidth, // Use default width if not provided
                            points: [{ x: message.x, y: message.y }],
                            start: { x: message.x, y: message.y },
                            end: { x: message.x, y: message.y },
                            isPeer: true,
                            isActive: true
                        });
                        redrawCanvas();
                    }
                    break;
                case 'ANNOTATION_END':
                    // Peer finished drawing - mark active element as inactive
                    if (message.id) {
                        const element = state.peerElements.find(el => el.id === message.id && el.isPeer);
                        if (element) {
                            element.isActive = false;
                        }
                    } else {
                        // Mark last active element as inactive
                        for (let i = state.peerElements.length - 1; i >= 0; i--) {
                            const el = state.peerElements[i];
                            if (el.isPeer && el.isActive) {
                                el.isActive = false;
                                break;
                            }
                        }
                    }
                    redrawCanvas();
                    break;
                case 'ANNOTATION_ELEMENT':
                    // Peer added a complete element (e.g., text)
                    state.peerElements.push({
                        ...message.element,
                        isPeer: true
                    });
                    redrawCanvas();
                    break;
                case 'ANNOTATION_CLEAR':
                    // Peer cleared canvas
                    state.peerElements = [];
                    redrawCanvas();
                    break;
                case 'ANNOTATION_SYNC':
                    // Full state sync
                    // Mark all synced elements as not active (they're complete)
                    const syncedElements = (message.elements || []).map(el => ({
                        ...el,
                        isPeer: true,
                        isActive: false
                    }));
                    state.peerElements = syncedElements;
                    redrawCanvas();
                    break;
            }
        }

        async function joinCollaborationWithCode(code) {
            if (!code || code.length !== 5) {
                alert('Invalid share code. Please enter a 5-character code.');
                return;
            }

            // Show connecting status
            updateConnectionStatus(false, null);
            const statusText = document.getElementById('connection-text');
            if (statusText) {
                statusText.textContent = 'Connecting...';
            }

            try {
                // Clean up any existing peer
                if (state.peer) {
                    state.peer.destroy();
                    state.peer = null;
                }

                state.peer = new Peer({
                    debug: 1,
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' }
                        ]
                    }
                });

                let connectionAttempted = false;

                state.peer.on('open', (id) => {
                    // Wait a bit to ensure peer is fully ready
                    setTimeout(() => {
                        if (connectionAttempted) return;
                        connectionAttempted = true;
                        
                        // Connect data channel with retry logic
                        attemptConnection(code);
                    }, 500);
                });

                state.peer.on('error', (err) => {
                    console.error('Peer error:', err);
                    
                    // Handle specific error types
                    if (err.type === 'peer-unavailable' || err.message?.includes('Could not connect')) {
                        if (statusText) {
                            statusText.textContent = 'Host not found';
                        }
                        setTimeout(() => {
                            alert('Could not connect to host. Please check:\n\n1. The share code is correct\n2. The host is still online\n3. Try again in a moment');
                            stopCollaboration();
                        }, 1000);
                    } else if (err.type === 'network') {
                        if (statusText) {
                            statusText.textContent = 'Network error';
                        }
                        alert('Network error. Please check your internet connection and try again.');
                        stopCollaboration();
                    } else {
                        if (statusText) {
                            statusText.textContent = 'Connection failed';
                        }
                        alert('Connection error: ' + (err.message || err.type || 'Unknown error'));
                        stopCollaboration();
                    }
                });

            } catch (err) {
                console.error('Error joining collaboration:', err);
                alert('Failed to join: ' + err.message);
                stopCollaboration();
            }
        }

        function attemptConnection(code, retryCount = 0) {
            const maxRetries = 3;
            const retryDelay = 2000; // 2 seconds

            try {
                // Connect data channel
                state.dataConnection = state.peer.connect(code, {
                    reliable: true
                });

                // Set connection timeout
                const connectionTimeout = setTimeout(() => {
                    if (!state.isCollaborating && state.dataConnection) {
                        if (state.dataConnection) {
                            state.dataConnection.close();
                            state.dataConnection = null;
                        }
                        
                        if (retryCount < maxRetries) {
                            setTimeout(() => attemptConnection(code, retryCount + 1), retryDelay);
                        } else {
                            alert('Could not connect to host after multiple attempts. Please check the share code and try again.');
                            stopCollaboration();
                        }
                    }
                }, 10000); // 10 second timeout

                state.dataConnection.on('open', () => {
                    clearTimeout(connectionTimeout);
                    // Store share code for status display
                    state.shareCode = code;
                    setupDataConnection(state.dataConnection);
                    
                    // Call for video stream after data connection is established
                    setTimeout(() => {
                        initiateVideoCall(code);
                    }, 500);
                });

                state.dataConnection.on('error', (err) => {
                    clearTimeout(connectionTimeout);
                    console.error('Data connection error:', err);
                    
                    if (retryCount < maxRetries) {
                        setTimeout(() => attemptConnection(code, retryCount + 1), retryDelay);
                    } else {
                        alert('Failed to establish connection. Please check the share code and try again.');
                        stopCollaboration();
                    }
                });

                state.dataConnection.on('close', () => {
                    clearTimeout(connectionTimeout);
                    if (!state.isCollaborating) {
                        if (retryCount < maxRetries) {
                            setTimeout(() => attemptConnection(code, retryCount + 1), retryDelay);
                        }
                    }
                });

            } catch (err) {
                console.error('Error attempting connection:', err);
                if (retryCount < maxRetries) {
                    setTimeout(() => attemptConnection(code, retryCount + 1), retryDelay);
                } else {
                    alert('Failed to connect: ' + err.message);
                    stopCollaboration();
                }
            }
        }

        function initiateVideoCall(code) {
            try {
                let streamToShare = null;
                if (state.mode === 'screen' && state.stream) {
                    streamToShare = state.stream;
                } else {
                    // Create dummy stream for non-screen modes
                    const canvas = document.createElement('canvas');
                    canvas.width = 1;
                    canvas.height = 1;
                    streamToShare = canvas.captureStream ? canvas.captureStream(1) : null;
                }
                
                if (streamToShare && state.peer) {
                    state.call = state.peer.call(code, streamToShare);
                    
                    if (state.call) {
                        setupCallHandlers(state.call);
                    }
                }
            } catch (err) {
                // Video call failure is not critical if data connection works
            }
        }

        function stopCollaboration() {
            if (state.dataConnection) {
                state.dataConnection.close();
                state.dataConnection = null;
            }
            if (state.call) {
                state.call.close();
                state.call = null;
            }
            if (state.peer) {
                state.peer.destroy();
                state.peer = null;
            }
            state.isCollaborating = false;
            state.isHosting = false;
            state.shareCode = null;
            state.peerElements = [];
            updateConnectionStatus(false);
            redrawCanvas();
        }

        // --- Initialization ---
        function init() {
            renderTools();
            renderColors();
            setupEventListeners();
            resizeCanvas();
            lucide.createIcons();
            updateUI();
            app.initTheme();
        }

        function renderTools() {
            toolContainer.innerHTML = TOOLS.map(t => `
                <button data-tool="${t.id}" title="${t.label}" 
                    class="annotate-tool-btn tool-btn p-3 rounded-xl flex justify-center transition-all duration-200 ${state.tool === t.id ? 'annotate-tool-btn-active shadow-lg scale-105' : ''}">
                    <i data-lucide="${t.icon}" class="w-5 h-5 pointer-events-none"></i>
                </button>
            `).join('');
        }

        function renderColors() {
            // Clear existing colors (except custom picker)
            const existingColors = colorContainer.querySelectorAll('.color-btn');
            existingColors.forEach(btn => btn.remove());
            
            // Render first 5 predefined colors
            const predefined = COLORS.slice(0, 5).map(c => `
                <button data-color="${c}" 
                    class="color-btn w-6 h-6 rounded-full border-2 transition-transform hover:scale-110 ${state.color === c ? 'border-white scale-110' : 'border-transparent'}"
                    style="background-color: ${c};">
                </button>
            `).join('');
            
            // Insert before the custom picker
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = predefined;
            const customPicker = colorContainer.querySelector('#custom-color-picker').parentElement;
            while (tempDiv.firstChild) {
                colorContainer.insertBefore(tempDiv.firstChild, customPicker);
            }
        }

        function setupEventListeners() {
            // Resize
            window.addEventListener('resize', () => {
                resizeCanvas();
                redrawCanvas();
            });

            // Canvas Interaction
            canvas.addEventListener('mousedown', handleStart);
            canvas.addEventListener('mousemove', handleMove);
            canvas.addEventListener('mouseup', handleEnd);
            canvas.addEventListener('mouseleave', handleEnd);
            
            // Touch support
            canvas.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                handleStart(mouseEvent);
            }, { passive: false });
            
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault(); 
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousemove', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                handleMove(mouseEvent);
            }, { passive: false });

            canvas.addEventListener('touchend', () => {
                const mouseEvent = new MouseEvent('mouseup', {});
                handleEnd(mouseEvent);
            });

            // Tools
            toolContainer.addEventListener('click', (e) => {
                const btn = e.target.closest('.tool-btn');
                if (btn) {
                    setTool(btn.dataset.tool);
                }
            });

            // Colors
            colorContainer.addEventListener('click', (e) => {
                const btn = e.target.closest('.color-btn');
                if (btn) {
                    setColor(btn.dataset.color);
                }
            });

            document.getElementById('custom-color-picker').addEventListener('input', (e) => {
                setColor(e.target.value);
            });

            // Stroke Slider
            strokeSlider.addEventListener('input', (e) => {
                state.strokeWidth = parseInt(e.target.value);
                strokeIndicator.style.height = `${state.strokeWidth}px`;
                if(state.tool === 'text') updateTextInputStyle();
            });

            // Actions
            document.getElementById('btn-undo').addEventListener('click', undo);
            document.getElementById('btn-redo').addEventListener('click', redo);
            document.getElementById('btn-clear').addEventListener('click', clearCanvas);
            document.getElementById('btn-snapshot').addEventListener('click', downloadSnapshot);

            // Modes
            document.getElementById('btn-mode-board').addEventListener('click', () => setMode('whiteboard'));
            document.getElementById('btn-mode-screen').addEventListener('click', startScreenShare);
            document.getElementById('btn-mode-image').addEventListener('click', () => document.getElementById('file-input').click());
            
            // Video Controls
            document.getElementById('btn-pause-video').addEventListener('click', toggleVideoPause);
            document.getElementById('btn-stop-share').addEventListener('click', stopScreenShare);

            // File Input
            document.getElementById('file-input').addEventListener('change', handleImageUpload);

            // Text Input logic
            textInputElem.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') confirmText();
            });
            textInputElem.addEventListener('blur', confirmText);

            // Collaboration button
            const btnCollaborate = document.getElementById('btn-collaborate');
            if (btnCollaborate) {
                btnCollaborate.addEventListener('click', () => {
                    if (state.isCollaborating) {
                        stopCollaboration();
                    } else {
                        showCollaborationModal();
                    }
                });
            }
        }

        // --- Collaboration Modal ---
        
        function showCollaborationModal() {
            const modal = document.getElementById('collaboration-modal-overlay');
            if (modal) {
                modal.classList.remove('hidden');
                // Reset join code input
                const joinInput = document.getElementById('join-code-input');
                if (joinInput) {
                    joinInput.value = '';
                    joinInput.focus();
                }
                if (window.lucide) lucide.createIcons();
            }
        }

        function closeCollaborationModal(event) {
            // Only close if clicking overlay or close button
            if (event && event.target.id !== 'collaboration-modal-overlay' && event.target.id !== 'close-collaboration-modal' && !event.target.closest('#close-collaboration-modal')) {
                return;
            }
            const modal = document.getElementById('collaboration-modal-overlay');
            if (modal) {
                modal.classList.add('hidden');
            }
        }

        function handleHostSession() {
            closeCollaborationModal();
            startCollaboration();
        }

        function handleJoinSession() {
            const joinInput = document.getElementById('join-code-input');
            const code = joinInput ? joinInput.value.trim().toUpperCase() : '';
            
            if (!code || code.length !== 5) {
                alert('Please enter a valid 5-character code');
                if (joinInput) joinInput.focus();
                return;
            }
            
            closeCollaborationModal();
            joinCollaborationWithCode(code);
        }

        // --- Core Logic ---

        function resizeCanvas() {
            const rect = container.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            redrawCanvas(); // Keep drawings after resize
        }

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        function setTool(toolId) {
            confirmText(); // Finish any active text
            state.tool = toolId;
            updateUI();
        }

        function setColor(colorHex) {
            state.color = colorHex;
            updateUI();
            if(state.textInput) {
                updateTextInputStyle();
            }
        }

        function updateUI() {
            // Update Tool Buttons
            document.querySelectorAll('.tool-btn').forEach(btn => {
                if (btn.dataset.tool === state.tool) {
                    btn.className = 'annotate-tool-btn tool-btn p-3 rounded-xl flex justify-center transition-all duration-200 annotate-tool-btn-active shadow-lg scale-105';
                } else {
                    btn.className = 'annotate-tool-btn tool-btn p-3 rounded-xl flex justify-center transition-all duration-200';
                }
            });

            // Update Color Buttons
            document.querySelectorAll('.color-btn').forEach(btn => {
                if (btn.dataset.color === state.color) {
                    btn.classList.add('border-white', 'scale-110');
                    btn.classList.remove('border-transparent');
                } else {
                    btn.classList.remove('border-white', 'scale-110');
                    btn.classList.add('border-transparent');
                }
            });

            // Update Mode Buttons
            const modeMap = { 'whiteboard': 'board', 'screen': 'screen', 'image': 'image' };
            ['board', 'screen', 'image'].forEach(m => {
                const btn = document.getElementById(`btn-mode-${m}`);
                if (state.mode === (m === 'board' ? 'whiteboard' : m)) {
                    btn.className = 'annotate-mode-btn px-3 py-1.5 rounded-md text-sm font-medium flex items-center space-x-1 transition-colors annotate-mode-btn-active';
                } else {
                    btn.className = 'annotate-mode-btn px-3 py-1.5 rounded-md text-sm font-medium flex items-center space-x-1 transition-colors';
                }
            });

            // Visibility of Backgrounds
            document.getElementById('bg-whiteboard').classList.toggle('hidden', state.mode !== 'whiteboard');
            document.getElementById('bg-screen').classList.toggle('hidden', state.mode !== 'screen');
            document.getElementById('bg-image').classList.toggle('hidden', state.mode !== 'image');

            // Undo/Redo State
            document.getElementById('btn-undo').disabled = state.historyStep < 0;
            document.getElementById('btn-redo').disabled = state.historyStep >= state.elements.length - 1;
        }

        // --- Drawing Logic ---

        function handleStart(e) {
            // Don't start drawing if clicking on controls inside canvas (unlikely with Z-index but safety first)
            if (e.target !== canvas) return;

            const { x, y } = getMousePos(e);

            if (state.tool === 'text') {
                if (state.textInput) {
                    confirmText(); // Clicked elsewhere while typing
                } else {
                    startText(x, y);
                }
                return;
            }

            // If text input is open and we switch tools/click, confirm it first
            if (state.textInput) confirmText();

            state.isDrawing = true;

            // Generate unique ID for this element
            const elementId = `local-${Date.now()}-${Math.random()}`;
            const newElement = {
                id: elementId,
                type: state.tool,
                color: state.tool === 'eraser' ? '#000000' : state.color,
                width: state.strokeWidth,
                points: [{ x, y }],
                start: { x, y },
                end: { x, y },
                isActive: true
            };

            // Slice history for redo path
            state.elements = state.elements.slice(0, state.historyStep + 1);
            state.elements.push(newElement);
            state.historyStep++;

            // Send to peer
            if (state.isCollaborating) {
                const sent = sendToPeer({
                    type: 'ANNOTATION_START',
                    id: elementId,
                    tool: state.tool,
                    color: newElement.color,
                    width: newElement.width,
                    x: x,
                    y: y
                });
            }

            updateUI(); // For undo button state
            redrawCanvas(); // Draw the initial point
        }

        function handleMove(e) {
            if (!state.isDrawing) return;
            const { x, y } = getMousePos(e);
            const currentElement = state.elements[state.historyStep];

            if (state.tool === 'pencil' || state.tool === 'eraser') {
                currentElement.points.push({ x, y });
            } else {
                currentElement.end = { x, y };
            }

            // Send to peer
            if (state.isCollaborating) {
                const currentElement = state.elements[state.historyStep];
                const sent = sendToPeer({
                    type: 'ANNOTATION_MOVE',
                    id: currentElement ? currentElement.id : null,
                    tool: state.tool,
                    x: x,
                    y: y
                });
            }

            redrawCanvas();
        }

        function handleEnd(e) {
            if (state.isDrawing && state.isCollaborating) {
                const currentElement = state.elements[state.historyStep];
                if (currentElement) {
                    currentElement.isActive = false;
                    sendToPeer({ 
                        type: 'ANNOTATION_END',
                        id: currentElement.id
                    });
                } else {
                    sendToPeer({ type: 'ANNOTATION_END' });
                }
            }
            state.isDrawing = false;
        }

        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw local elements
            const itemsToDraw = state.elements.slice(0, state.historyStep + 1);
            drawElements(itemsToDraw);

            // Draw peer elements
            if (state.peerElements.length > 0) {
                drawElements(state.peerElements, true);
            }

            ctx.globalCompositeOperation = 'source-over';
        }

        function drawElements(elements, isPeer = false) {
            elements.forEach(el => {
                ctx.beginPath();
                ctx.strokeStyle = el.color;
                ctx.lineWidth = el.width;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // Make peer elements slightly transparent
                if (isPeer) {
                    ctx.globalAlpha = 0.8;
                }

                if (el.type === 'eraser') {
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.lineWidth = el.width * 2; 
                } else {
                    ctx.globalCompositeOperation = 'source-over';
                }

                if (el.type === 'pencil' || el.type === 'eraser') {
                    if (el.points.length < 2) return;
                    ctx.moveTo(el.points[0].x, el.points[0].y);
                    for (let i = 1; i < el.points.length; i++) {
                        ctx.lineTo(el.points[i].x, el.points[i].y);
                    }
                    ctx.stroke();
                } else if (el.type === 'arrow') {
                    drawArrow(ctx, el.start.x, el.start.y, el.end.x, el.end.y);
                } else if (el.type === 'rect') {
                    ctx.strokeRect(el.start.x, el.start.y, el.end.x - el.start.x, el.end.y - el.start.y);
                } else if (el.type === 'text_rendered') {
                    ctx.font = `${el.width * 6}px sans-serif`;
                    ctx.fillStyle = el.color;
                    ctx.fillText(el.text, el.start.x, el.start.y);
                }

                if (isPeer) {
                    ctx.globalAlpha = 1.0;
                }
            });
        }

        function drawArrow(ctx, fromx, fromy, tox, toy) {
            const headlen = 15; 
            const dx = tox - fromx;
            const dy = toy - fromy;
            const angle = Math.atan2(dy, dx);
            
            ctx.moveTo(fromx, fromy);
            ctx.lineTo(tox, toy);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(tox, toy);
            ctx.lineTo(tox - headlen * Math.cos(angle - Math.PI / 6), toy - headlen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(tox - headlen * Math.cos(angle + Math.PI / 6), toy - headlen * Math.sin(angle + Math.PI / 6));
            ctx.lineTo(tox, toy);
            ctx.lineTo(tox - headlen * Math.cos(angle - Math.PI / 6), toy - headlen * Math.sin(angle - Math.PI / 6));
            ctx.fillStyle = ctx.strokeStyle;
            ctx.fill();
        }

        // --- Text Tool Logic ---

        function startText(x, y) {
            state.textInput = { x, y, text: '' };
            
            textInputElem.value = '';
            textInputElem.style.left = `${x}px`;
            textInputElem.style.top = `${y}px`;
            textInputElem.classList.remove('hidden');
            updateTextInputStyle();
            
            // Wait a tick for visibility then focus
            setTimeout(() => textInputElem.focus(), 10);
        }

        function updateTextInputStyle() {
            textInputElem.style.fontSize = `${state.strokeWidth * 6}px`;
            textInputElem.style.color = state.color;
            textInputElem.style.textShadow = '0 1px 2px rgba(0,0,0,0.3)';
        }

        function confirmText() {
            if (!state.textInput) return;
            
            const text = textInputElem.value.trim();
            if (text) {
                const newElement = {
                    type: 'text_rendered',
                    color: state.color,
                    width: state.strokeWidth,
                    text: text,
                    start: { x: state.textInput.x, y: state.textInput.y }
                };
                
                state.elements = state.elements.slice(0, state.historyStep + 1);
                state.elements.push(newElement);
                state.historyStep++;
                
                // Send to peer
                if (state.isCollaborating) {
                    // Generate ID for text element if not present
                    if (!newElement.id) {
                        newElement.id = `local-${Date.now()}-${Math.random()}`;
                    }
                    sendToPeer({
                        type: 'ANNOTATION_ELEMENT',
                        element: newElement
                    });
                }
                
                redrawCanvas();
            }

            // Reset
            state.textInput = null;
            textInputElem.classList.add('hidden');
            textInputElem.value = '';
            updateUI();
        }

        // --- History & Actions ---

        function undo() {
            if (state.historyStep >= 0) {
                state.historyStep--;
                redrawCanvas();
                updateUI();
            }
        }

        function redo() {
            if (state.historyStep < state.elements.length - 1) {
                state.historyStep++;
                redrawCanvas();
                updateUI();
            }
        }

        function clearCanvas() {
            state.elements = [];
            state.historyStep = -1;
            
            // Send to peer
            if (state.isCollaborating) {
                sendToPeer({ type: 'ANNOTATION_CLEAR' });
            }
            
            redrawCanvas();
            updateUI();
        }

        // --- Screen & Image Modes ---

        function setMode(newMode) {
            // Stop screen share if leaving screen mode
            if (state.mode === 'screen' && newMode !== 'screen') {
                stopScreenShareLogic();
            }
            state.mode = newMode;
            updateUI();
        }

        async function startScreenShare() {
            try {
                const mediaStream = await navigator.mediaDevices.getDisplayMedia({
                    video: { cursor: "always" },
                    audio: false
                });
                state.stream = mediaStream;
                videoElem.srcObject = mediaStream;
                videoPlaceholder.classList.add('hidden');
                videoControls.classList.remove('hidden');
                
                setMode('screen');

                // If collaborating, share the screen stream with connected peers
                if (state.isCollaborating) {
                    shareScreenWithPeers(mediaStream);
                }

                // Detect system stop
                mediaStream.getVideoTracks()[0].onended = () => {
                    stopScreenShare();
                };
            } catch (err) {
                console.error("Error sharing screen:", err);
                setMode('whiteboard');
            }
        }

        function shareScreenWithPeers(stream) {
            if (!state.isCollaborating || !stream) return;

            // If we're the host and have an active call, replace the track
            if (state.isHosting && state.call && state.call.peerConnection) {
                const videoTrack = stream.getVideoTracks()[0];
                if (videoTrack) {
                    const senders = state.call.peerConnection.getSenders();
                    const videoSender = senders.find(s => 
                        s.track && s.track.kind === 'video'
                    );
                    
                    if (videoSender) {
                        videoSender.replaceTrack(videoTrack).then(() => {
                        }).catch(err => {
                            console.error('Error replacing track:', err);
                            // If replace fails, close and recreate the call
                            recreateCallWithStream(stream);
                        });
                    } else {
                        // No video sender found, recreate call
                        recreateCallWithStream(stream);
                    }
                }
            } 
            // If we're the host and have data connection but no call, initiate call
            else if (state.isHosting && state.dataConnection && !state.call && state.dataConnection.open) {
                const peerId = state.dataConnection.peer;
                if (peerId && state.peer) {
                    state.call = state.peer.call(peerId, stream);
                    setupCallHandlers(state.call);
                }
            }
            // If we're a joiner, we should send our stream to the host
            else if (!state.isHosting && state.dataConnection && state.dataConnection.open) {
                const peerId = state.dataConnection.peer;
                if (peerId && state.peer && !state.call) {
                    state.call = state.peer.call(peerId, stream);
                    setupCallHandlers(state.call);
                } else if (state.call && state.call.peerConnection) {
                    // Update existing call
                    const videoTrack = stream.getVideoTracks()[0];
                    if (videoTrack) {
                        const senders = state.call.peerConnection.getSenders();
                        const videoSender = senders.find(s => 
                            s.track && s.track.kind === 'video'
                        );
                        if (videoSender) {
                            videoSender.replaceTrack(videoTrack).catch(err => {
                                console.error('Error replacing track as joiner:', err);
                            });
                        }
                    }
                }
            }
        }

        function recreateCallWithStream(stream) {
            if (!state.isHosting || !state.dataConnection || !state.dataConnection.open) return;
            
            const peerId = state.dataConnection.peer;
            if (!peerId || !state.peer) return;

            // Close existing call
            if (state.call) {
                state.call.close();
                state.call = null;
            }

            // Create new call with screen stream
            state.call = state.peer.call(peerId, stream);
            setupCallHandlers(state.call);
        }

        function setupCallHandlers(call) {
            if (!call) return;

            call.on('stream', (remoteStream) => {
                // Handle remote stream - could display it in a separate video element
                // For now, we'll just log it since the main screen share is shown locally
            });

            call.on('close', () => {
                if (state.call === call) {
                    state.call = null;
                }
            });

            call.on('error', (err) => {
                console.error('Call error:', err);
            });
        }

        function stopScreenShare() {
            stopScreenShareLogic();
            setMode('whiteboard');
        }

        function stopScreenShareLogic() {
            // If collaborating, replace stream with dummy stream to notify peers
            if (state.isCollaborating && state.call && state.call.peerConnection) {
                const canvas = document.createElement('canvas');
                canvas.width = 1;
                canvas.height = 1;
                const dummyStream = canvas.captureStream ? canvas.captureStream(1) : null;
                
                if (dummyStream) {
                    const videoTrack = dummyStream.getVideoTracks()[0];
                    if (videoTrack) {
                        const senders = state.call.peerConnection.getSenders();
                        const videoSender = senders.find(s => 
                            s.track && s.track.kind === 'video'
                        );
                        if (videoSender) {
                            videoSender.replaceTrack(videoTrack).catch(err => {
                                console.error('Error replacing track with dummy:', err);
                            });
                        }
                    }
                }
            }

            if (state.stream) {
                state.stream.getTracks().forEach(track => track.stop());
                state.stream = null;
            }
            videoElem.srcObject = null;
            videoPlaceholder.classList.remove('hidden');
            videoControls.classList.add('hidden');
            document.getElementById('video-frozen-badge').classList.add('hidden');
            state.isVideoPaused = false;
        }

        function toggleVideoPause() {
            if (!videoElem.srcObject) return;
            
            state.isVideoPaused = !state.isVideoPaused;
            if (state.isVideoPaused) {
                videoElem.pause();
                document.getElementById('icon-pause').classList.add('hidden');
                document.getElementById('icon-play').classList.remove('hidden');
                document.getElementById('video-frozen-badge').classList.remove('hidden');
                videoElem.style.opacity = '0.6';
            } else {
                videoElem.play();
                document.getElementById('icon-pause').classList.remove('hidden');
                document.getElementById('icon-play').classList.add('hidden');
                document.getElementById('video-frozen-badge').classList.add('hidden');
                videoElem.style.opacity = '1';
            }
        }

        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (evt) => {
                    state.backgroundImageSrc = evt.target.result;
                    imgElem.src = state.backgroundImageSrc;
                    imgElem.classList.remove('hidden');
                    imgPlaceholder.classList.add('hidden');
                    
                    // Stop screen share if active
                    if (state.mode === 'screen') stopScreenShareLogic();
                    
                    setMode('image');
                };
                reader.readAsDataURL(file);
            }
            e.target.value = ''; // Reset input
        }

        // --- Export ---

        function downloadSnapshot() {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tCtx = tempCanvas.getContext('2d');

            // 1. Draw Background
            if (state.mode === 'whiteboard') {
                const theme = document.documentElement.getAttribute('data-theme') || 'light';
                tCtx.fillStyle = theme === 'dark' ? '#1f2937' : '#ffffff';
                tCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                drawAnnotationsAndSave(tempCanvas, tCtx);
            } 
            else if (state.mode === 'screen' && videoElem.srcObject) {
                const vRatio = tempCanvas.width / videoElem.videoWidth;
                const hRatio = tempCanvas.height / videoElem.videoHeight;
                const ratio = Math.min(vRatio, hRatio);
                const centerShift_x = (tempCanvas.width - videoElem.videoWidth * ratio) / 2;
                const centerShift_y = (tempCanvas.height - videoElem.videoHeight * ratio) / 2;

                tCtx.drawImage(videoElem, 0, 0, videoElem.videoWidth, videoElem.videoHeight,
                               centerShift_x, centerShift_y, videoElem.videoWidth * ratio, videoElem.videoHeight * ratio);
                drawAnnotationsAndSave(tempCanvas, tCtx);
            } 
            else if (state.mode === 'image' && state.backgroundImageSrc) {
                const img = new Image();
                img.onload = () => {
                    const hRatio = tempCanvas.width / img.width;
                    const vRatio = tempCanvas.height / img.height;
                    const ratio = Math.min(hRatio, vRatio);
                    const centerShift_x = (tempCanvas.width - img.width * ratio) / 2;
                    const centerShift_y = (tempCanvas.height - img.height * ratio) / 2;
                    
                    tCtx.drawImage(img, 0, 0, img.width, img.height,
                                   centerShift_x, centerShift_y, img.width * ratio, img.height * ratio);
                    drawAnnotationsAndSave(tempCanvas, tCtx);
                };
                img.src = state.backgroundImageSrc;
            } else {
                // Fallback (e.g. empty image mode)
                const theme = document.documentElement.getAttribute('data-theme') || 'light';
                tCtx.fillStyle = theme === 'dark' ? '#111827' : '#f9fafb';
                tCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                drawAnnotationsAndSave(tempCanvas, tCtx);
            }
        }

        function drawAnnotationsAndSave(tempCanvas, tCtx) {
            // Draw current canvas on top
            tCtx.drawImage(canvas, 0, 0);
            
            // Download
            const link = document.createElement('a');
            link.download = `annotation-${Date.now()}.png`;
            link.href = tempCanvas.toDataURL();
            link.click();
        }

        // Make app available globally
        window.app = app;

        // Make modal functions globally available
        window.closeCollaborationModal = closeCollaborationModal;
        window.handleHostSession = handleHostSession;
        window.handleJoinSession = handleJoinSession;

        // Start App
        init();

    </script>
</body>
</html>